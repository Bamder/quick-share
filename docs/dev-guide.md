# 开发指南

本文档用最简单的语言描述系统的核心机制。

## 目录

1. [两个池机制](#两个池机制)
2. [标识码映射机制](#标识码映射机制)
3. [12位取件码机制](#12位取件码机制)
4. [文件去重机制](#文件去重机制)
5. [加密密钥机制](#加密密钥机制)
6. [定时清理机制](#定时清理机制)
7. [延时机制](#延时机制)

---

## 两个池机制

系统使用两个内存池来优化性能：

### 上传池（upload_pool）

**作用**：临时存储正在上传的文件块

**工作流程**：
1. 用户上传文件块时，先写入上传池（内存操作，速度快）
2. 所有块上传完成后，批量写入主缓存（Redis/内存）
3. 写入完成后，清空上传池

**好处**：
- 减少对主缓存的频繁写入
- 提高上传速度
- 如果上传失败，自动清理临时数据

**清理规则**：超过1小时未完成上传的数据会被自动清理

### 下载池（download_pool）

**作用**：预读取文件块到内存，加速下载

**工作流程**：
1. 用户开始下载时，系统预读取后续10-25个块到下载池
2. 用户请求块时，优先从下载池读取（内存操作，速度快）
3. 如果下载池没有，再从主缓存读取

**好处**：
- 减少对主缓存的频繁读取
- 提高下载速度
- 每个下载会话有独立的池，避免冲突

**清理规则**：超过10分钟未访问的会话会被自动清理

---

## 标识码映射机制

**核心概念**：标识码是文件的唯一标识，与文件缓存强绑定。

### 为什么需要标识码？

- 一个文件可能被多次分享，产生多个取件码
- 所有取件码应该共享同一个文件缓存（避免重复存储）
- 即使原始取件码过期，文件缓存仍然存在（供新取件码使用）

### 工作原理

1. **标识码的生成**：
   - 第一次上传文件时，生成的取件码就是标识码
   - 标识码与文件缓存强绑定：缓存延时 => 标识码延时；缓存过期 => 标识码过期

2. **映射关系**：
   - 所有取件码（包括原始取件码）都映射到同一个标识码
   - 映射关系存储在：内存、Redis、数据库

3. **访问文件缓存**：
   - 取件码不能直接访问文件缓存
   - 必须先通过映射获取标识码
   - 使用标识码访问文件块缓存和文件信息缓存

### 示例

```
文件A第一次上传 → 生成取件码 ABC123 → 标识码 = ABC123
文件A第二次分享 → 生成取件码 XYZ789 → 映射到标识码 ABC123

访问文件缓存：
- 取件码 ABC123 → 标识码 ABC123 → 访问缓存
- 取件码 XYZ789 → 标识码 ABC123 → 访问缓存（共享同一个缓存）
```

---

## 12位取件码机制

取件码由两部分组成：**6位查找码 + 6位密钥码**

### 查找码（前6位）

- **作用**：服务器用来查找取件码记录
- **存储**：存储在数据库中
- **示例**：`ABC123`

### 密钥码（后6位）

- **作用**：客户端用来派生密钥，加密/解密文件加密密钥
- **存储**：**不存储在服务器**，只在客户端使用
- **示例**：`XYZ789`

### 完整取件码（12位）

- **格式**：`ABC123XYZ789`（查找码 + 密钥码）
- **使用**：前端使用完整取件码，后端只接收查找码

### 安全性

- 服务器**永远不接触**密钥码
- 即使数据库泄露，攻击者也无法解密文件（缺少密钥码）
- 只有拥有完整12位取件码的人才能解密文件

---

## 文件去重机制

系统使用**源文件哈希**进行文件去重，确保相同文件的重复上传能够复用缓存。

### 哈希计算策略

- **前端计算**：对**原始文件（未加密）**计算SHA-256哈希
- **后端存储**：使用HMAC-SHA256生成去重指纹（用户ID + 文件哈希 + 服务器盐）
- **去重匹配**：相同用户 + 相同文件 = 复用缓存；不同用户 = 独立存储

### 设计优势

- ✅ **算法独立**：哈希不受加密算法变更影响
- ✅ **用户隔离**：不同用户相同文件不会互相复用
- ✅ **隐私保护**：数据库不存储明文文件哈希
- ✅ **缓存复用**：重复上传立即完成，无需重新加密

### 为什么不使用加密文件哈希？

加密文件哈希会带来密钥依赖性问题：
- 同一文件不同密钥 → 不同哈希 → 无法去重
- 密钥变更 → 哈希失效 → 缓存混乱
- 前端无法计算 → 失去本地缓存能力

---

## 加密密钥机制

系统使用两层加密：

### 第一层：文件加密密钥

- **生成**：客户端随机生成AES-GCM密钥（256位）
- **作用**：直接加密/解密文件块
- **存储**：**不直接存储**，而是加密后存储

### 第二层：密钥码派生密钥

- **生成**：使用取件码的后6位密钥码派生密钥
- **作用**：加密/解密文件加密密钥
- **存储**：加密后的文件加密密钥存储在服务器

### 工作流程

1. **上传时**：
   ```
   客户端生成文件加密密钥 → 用密钥码派生密钥加密 → 发送加密后的密钥到服务器
   ```

2. **下载时**：
   ```
   服务器返回加密后的密钥 → 客户端用密钥码派生密钥解密 → 得到文件加密密钥 → 解密文件块
   ```

### 密钥缓存

- **存储位置**：每个取件码的密钥缓存独立存储
- **原因**：不同取件码的密钥码不同，加密后的密钥也不同
- **过期**：密钥缓存与取件码一起过期，不随文件缓存延时

---

## 定时清理机制

系统定期清理过期的数据，保持系统整洁。

### 清理范围

1. **数据库**：删除过期的取件码记录
2. **Redis缓存**：删除过期的文件块、文件信息、密钥、映射关系
3. **内存缓存**：删除过期的文件块、文件信息、密钥、映射关系
4. **上传池**：清理超过1小时未完成上传的数据
5. **下载池**：清理超过10分钟未访问的会话

### 清理策略

1. **基于数据库**：查询所有过期的取件码
2. **获取标识码**：通过映射关系获取标识码
3. **清理缓存**：
   - 使用标识码清理文件块缓存和文件信息缓存
   - 使用取件码清理密钥缓存（每个取件码独立存储）
4. **清理映射**：删除过期的映射关系
5. **清理数据库**：删除过期的取件码记录（先删除关联记录，避免外键约束）

### 清理时机

- 系统启动时执行一次
- 之后每隔一定时间自动执行（可配置）

---

## 延时机制

**核心概念**：当新取件码复用文件缓存时，延长文件缓存的过期时间。

### 触发条件

只有当以下情况同时满足时，才会触发延时：
1. 前端原始密钥存在（用户之前上传过该文件）
2. 后端文件缓存存在（文件块缓存和文件信息缓存都存在）
3. 用户选择复用文件缓存（只上传加密密钥，不重新上传文件块）

### 延时逻辑

1. **获取所有相关取件码**：找到所有映射到同一标识码的取件码
2. **计算最晚过期时间**：取所有相关取件码中最晚的过期时间
3. **更新缓存过期时间**：
   - 更新文件块缓存的过期时间
   - 更新文件信息缓存的过期时间
   - **不更新**密钥缓存的过期时间（每个取件码独立存储）

### 不延时的场景

以下情况**不会**触发延时：
1. 前端原始密钥丢失 → 需要重新上传所有内容
2. 后端文件缓存丢失 → 需要重新上传所有内容
3. 用户选择重新上传 → 直接更新所有缓存

### 示例

```
场景：用户上传文件A，生成取件码 ABC123（过期时间：明天）
     用户再次分享文件A，生成取件码 XYZ789（过期时间：后天）

延时前：
- 文件块缓存过期时间：明天（跟随 ABC123）

延时后：
- 文件块缓存过期时间：后天（取最晚的过期时间）
- 取件码 ABC123 的密钥缓存：仍然明天过期（不延时）
- 取件码 XYZ789 的密钥缓存：后天过期（独立存储）
```

---

## 总结

- **两个池**：上传池和下载池，优化性能
- **标识码**：文件的唯一标识，所有取件码映射到标识码，通过标识码访问文件缓存
- **12位取件码**：6位查找码（服务器用）+ 6位密钥码（客户端用），提高安全性
- **加密密钥**：两层加密，文件加密密钥用密钥码派生密钥加密
- **定时清理**：定期清理过期数据，保持系统整洁
- **延时机制**：复用文件缓存时，延长文件缓存的过期时间（不延长密钥缓存）

